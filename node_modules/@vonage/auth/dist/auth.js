"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const jwt_1 = require("@vonage/jwt");
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const enums_1 = require("./enums");
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('vonage:auth');
class Auth {
    apiKey;
    apiSecret;
    privateKey;
    applicationId;
    signature;
    jwtOptions;
    constructor(opts) {
        this.apiKey = opts?.apiKey || '';
        this.apiSecret = opts?.apiSecret || '';
        this.signature = opts?.signature || null;
        this.applicationId = opts?.applicationId || null;
        this.jwtOptions = opts?.jwtOptions || {};
        if (!opts?.privateKey) {
            log('No private key set');
            return;
        }
        if ((0, fs_1.existsSync)(opts.privateKey)) {
            log('Reading private key file');
            opts.privateKey = (0, fs_1.readFileSync)(opts.privateKey).toString();
        }
        this.privateKey = opts.privateKey instanceof Buffer
            ? opts.privateKey.toString()
            : opts.privateKey;
    }
    getQueryParams = async (params) => ({
        ...params,
        api_key: this.apiKey,
        api_secret: this.apiSecret,
    });
    createBasicHeader = async () => {
        log('Creating basic auth header');
        const buf = Buffer.from(`${this.apiKey}:${this.apiSecret}`);
        return `Basic ${buf.toString('base64')}`;
    };
    createBearerHeader = async () => {
        log('Creating bearer header');
        return `Bearer ${(0, jwt_1.tokenGenerate)(this.applicationId, this.privateKey, this.jwtOptions)}`;
    };
    createSignatureHash = async (params) => {
        log('Creating signature hash');
        const returnParams = {
            ...params,
            api_key: this.apiKey,
        };
        if (!returnParams.timestamp) {
            returnParams.timestamp = Math.floor(Date.now() / 1000).toString();
        }
        const sortedParams = new URLSearchParams(returnParams);
        sortedParams.sort();
        const stringifiedParamsforSigning = sortedParams
            .toString()
            .replace(/(&|=)/gi, '_');
        switch (this.signature.algorithm) {
            case enums_1.AlgorithmTypes.md5hash:
                returnParams.sig = (0, crypto_1.createHash)('md5')
                    .update(`${stringifiedParamsforSigning}${this.signature.secret}`)
                    .digest('hex');
                break;
            case enums_1.AlgorithmTypes.md5hmac:
                returnParams.sig = (0, crypto_1.createHmac)('md5', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
                break;
            case enums_1.AlgorithmTypes.sha1hmac:
                returnParams.sig = (0, crypto_1.createHmac)('sha1', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
                break;
            case enums_1.AlgorithmTypes.sha256hmac:
                returnParams.sig = (0, crypto_1.createHmac)('sha256', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
                break;
            case enums_1.AlgorithmTypes.sha512hmac:
                returnParams.sig = (0, crypto_1.createHmac)('sha512', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
                break;
            default:
                throw new Error(`Cannot sign request! Invalid algorithm: ${this.signature.algorithm}`);
        }
        return returnParams;
    };
}
exports.Auth = Auth;
//# sourceMappingURL=auth.js.map